# ==============================================================================
# Casbin Modell-Konfiguration
# Modell-Typ: ACL / Flaches RBAC (Role-Based Access Control)
# Beschreibung: Definition der Syntax und Semantik für die Zugriffskontrolle.
# ==============================================================================

[request_definition]
# Definition der Struktur einer eingehenden Zugriffsanfrage.
# r = Tupel aus (Subjekt, Objekt, Aktion)
# - sub: Das zugreifende Subjekt (hier: die Benutzerrolle, z. B. 'Mitarbeiter')
# - obj: Das zu schützende Objekt (hier: die Datenklassifizierung, z. B. 'secret')
# - act: Die auszuführende Operation (hier: implizit immer 'read')
r = sub, obj, act

[policy_definition]
# Definition des Schemas für die Persistierung der Regeln (in rbac_policy.csv).
# p = Tupel aus (Subjekt, Objekt, Aktion)
# Dies stellt sicher, dass die Spalten der CSV-Datei korrekt auf die Logik abgebildet werden.
p = sub, obj, act

[policy_effect]
# Definition der Entscheidungslogik (Effect).
# 'some(where (p.eft == allow))' implementiert einen Whitelist-Ansatz.
# Bedeutung: Der Zugriff wird gewährt, wenn mindestens eine Regel existiert,
# die den Zugriff explizit erlaubt. Standardmäßig wird verweigert (Default Deny).
e = some(where (p.eft == allow))

[matchers]
# Definition der Evaluierungslogik (Matching Function).
# Hier wird geprüft, ob die Attribute der Anfrage (r) exakt mit den
# Attributen einer Policy-Regel (p) übereinstimmen.
#
# Logik:
# 1. Stimmt die angefragte Rolle mit der Policy-Rolle überein?
# 2. Stimmt die angefragte Klassifizierung mit der Policy-Klassifizierung überein?
# 3. Stimmt die angefragte Aktion mit der Policy-Aktion überein?
m = r.sub == p.sub && r.obj == p.obj && r.act == p.act